// /*! \file
//  * Implementation of a simple memory allocator.  The allocator manages a small
//  * pool of memory, provides memory chunks on request, and reintegrates freed
//  * memory back into the pool.
//  *
//  * Adapted from Andre DeHon's CS24 2004, 2006 material.
//  * Copyright (C) California Institute of Technology, 2004-2010.
//  * All rights reserved.
//  */
//
// #include <stdio.h>
// #include <stdlib.h>
//
// #include "myalloc.h"
//
//
// /*!
//  * These variables are used to specify the size and address of the memory pool
//  * that the simple allocator works against.  The memory pool is allocated within
//  * init_myalloc(), and then myalloc() and free() work against this pool of
//  * memory that mem points to.
//  */
// //int * header;
// int MEMORY_SIZE;
// unsigned char *mem;
//
// static unsigned char *freeptr;
//
//
// /*!
//  * This function initializes both the allocator state, and the memory pool.  It
//  * must be called before myalloc() or myfree() will work at all.
//  *
//  * Note that we allocate the entire memory pool using malloc().  This is so we
//  * can create different memory-pool sizes for testing.  Obviously, in a real
//  * allocator, this memory pool would either be a fixed memory region, or the
//  * allocator would request a memory region from the operating system (see the
//  * C standard function sbrk(), for example).
//  */
// void init_myalloc() {
//
//     /*
//      * Allocate the entire memory pool, from which our simple allocator will
//      * serve allocation requests.
//      */
//
//      /* We're using headers and footers in our memory block representation*/
//     mem = (unsigned char *) malloc(MEMORY_SIZE);
//     if (mem == 0) {
//         fprintf(stderr,
//                 "init_myalloc: could not get %d bytes from the system\n",
// 		MEMORY_SIZE);
//         abort();
//     }
//     *((int*) mem) = MEMORY_SIZE - 2*sizeof(int);
// }
//
//
// /*!
//  * Attempt to allocate a chunk of memory of "size" bytes.  Return 0 if
//  * allocation fails.
//  */
// unsigned char *myalloc(int size) {
//      // before we reach the end of the memory pool
//
//     unsigned char * current_block = mem;
//     int current_space = *((int *) current_block);
//     int location_idx = 0;
//
//     while (size > current_space) {
//       location_idx += abs(current_space) + sizeof(int);
//       if (location_idx >= MEMORY_SIZE) {
//         current_block = NULL;
//         break;
//       }
//       else {
//         current_block += abs(current_space) + sizeof(int);
//         current_space = *((int *) current_block);
//       }
//     }
//
//     if (current_block) {
//       unsigned char * resultptr = current_block + sizeof(int);
//       if (current_space - size >= sizeof(int)) {
//         *((int *) current_block) = -size;
//         *((int *) current_block + sizeof(int) + size) = current_space - size - sizeof(int);
//       }
//       else {
//         *((int *) current_block) = -current_space;
//       }
//       return resultptr;
//     }
//     else {
//         fprintf(stderr, "myalloc: cannot service request of size %d with"
//                 " %lx bytes allocated\n", size, (freeptr - mem));
//         return (unsigned char *) 0;
//     }
// }
//
//
// /*!
//  * Free a previously allocated pointer.  oldptr should be an address returned by
//  * myalloc().
//  */
// void myfree(unsigned char *oldptr) {
//     oldptr -= sizeof(int);
//     int size = *((int*) oldptr);
//     *((int*) oldptr) = abs(size);
//
//     unsigned char * right_block = oldptr + sizeof(int) - size;
//     if (*((int *) right_block) > 0) {
//       *((int*) oldptr) += sizeof(int) + *((int *) right_block);
//     }
//
//     unsigned char * current_block = mem;
//     int current_size = *((int *) current_block);
//     unsigned char * next_block;
//     int next_size;
//
//     int next_loc_idx = abs(current_size) + sizeof(int);
//     while(next_loc_idx < MEMORY_SIZE - sizeof(int)) {
//       next_block = current_block + sizeof(int) + abs(current_size);
//       next_size = *((int *) next_block);
//
//       if (next_size > 0 && current_size > 0) {
//         *((int *) current_block) += next_size + sizeof(int);
//         break;
//       }
//       else {
//         current_block = next_block;
//         current_size = next_size;
//         next_loc_idx += abs(current_size) + sizeof(int);
//       }
//     }
// }
//
// /*!
//  * Clean up the allocator state.
//  * All this really has to do is free the user memory pool. This function mostly
//  * ensures that the test program doesn't leak memory, so it's easy to check
//  * if the allocator does.
//  */
// void close_myalloc() {
//     free(mem);
// }
