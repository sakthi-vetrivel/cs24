SOURCES=bus.c branching_program_counter.c instruction_store.c \
	branching_decode.c register_file.c alu.c branching_control.c \
	branch_unit.c branching_processor.c run.c

OBJECTS=$(SOURCES:.c=.o)


# Use the GNU compiler gcc
CC=gcc


# Report all warnings, and report them as errors.  Warnings should *always*
# be fixed.  Also, enable debug output, and branching support in our program.
CFLAGS = -Wall -Werror -g -DBRANCHING
CFLAGS += -Wno-error=unused-but-set-variable


all: branching_run testalu


branching_run: $(OBJECTS)
	$(CC) $(CFLAGS) -o branching_run $^ $(LDFLAGS)

testalu: alu.o bus.o testalu.o
	$(CC) $(CFLAGS) -o testalu $^ $(LDFLAGS)

clean:
	rm -f *.o branching_run testalu *~


.PHONY = clean all


# This section records the dependencies of object files on their corresponding
# source and header files, so that when a header file changes, the object file
# can be rebuilt.  It is typically generated by makedepend, which is why the
# output is gross looking.

branching_program_counter.o:	branching_program_counter.c branching_program_counter.h instruction.h bus.h
instruction_store.o:	instruction_store.c instruction_store.h bus.h
branching_decode.o:	branching_decode.c branching_decode.h instruction.h bus.h
register_file.o:	register_file.c register_file.h instruction.h bus.h
alu.o:	alu.c alu.h instruction.h bus.h
branching_control.o:	branching_control.c alu.h register_file.h branching_decode.h instruction_store.h branching_program_counter.h
branch_unit.o:	branch_unit.c instruction.h bus.h
branching_processor.o:	branching_processor.c alu.h register_file.h branching_decode.h instruction_store.h branching_program_counter.h branching_control.h

